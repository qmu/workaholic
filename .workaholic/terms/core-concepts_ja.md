---
title: Core Concepts
description: Fundamental building blocks of the Workaholic plugin system
category: developer
last_updated: 2026-01-31
commit_hash: 06ebf65
---

[English](core-concepts.md) | [日本語](core-concepts_ja.md)

# コアコンセプト

Workaholicプラグインシステムの基本的な構成要素。

## plugin

Claude Code機能を拡張するコマンド、スキル、ルール、エージェントのモジュラーコレクション。

### 定義

プラグインは関連する機能を単一の配布可能なユニットにパッケージ化します。各プラグインは`plugins/`下に独自のディレクトリを持ち、`plugin.json`メタデータを含む`.claude-plugin/`設定フォルダを含みます。プラグインはコマンド（ユーザー呼び出し可能）、スキル（ヘルパールーチン）、ルール（ガイドライン）、エージェント（特殊なサブエージェント）を定義できます。

### 使用パターン

- **ディレクトリ名**: `plugins/core/`
- **ファイル名**: `plugins/<name>/.claude-plugin/plugin.json`
- **コード参照**: 「coreプラグインをインストール」、「Coreプラグインコマンド」

### 関連用語

- command、skill、rule、agent

## command

特定のタスクを実行するユーザー呼び出し可能なスラッシュコマンド。

### 定義

コマンドはプラグインの主要なユーザーインターフェースです。ユーザーはスラッシュプレフィックスで呼び出します（例：`/ticket`、`/drive`）。各コマンドはプラグインの`commands/`ディレクトリにマークダウンファイルを持ち、その動作と指示を定義します。

### 使用パターン

- **ディレクトリ名**: `plugins/<name>/commands/`
- **ファイル名**: `ticket.md`、`drive.md`、`report.md`
- **コード参照**: 「`/drive`を実行して...」、「`/ticket`コマンド...」

### 関連用語

- skill、plugin

## skill

直接ユーザー呼び出しできないヘルパーサブルーチン。

### 定義

スキルはコマンドや他の操作をサポートする内部ルーチンです。コマンドとは異なり、ユーザーはスラッシュプレフィックスでスキルを直接呼び出すことはできません。通常、コマンドによって呼び出されるか、自動的にトリガーされます。スキルはプラグインの`skills/`ディレクトリ内の独自のサブディレクトリに定義され、`SKILL.md`定義と、POSIXシェルスクリプトを含むオプションの`sh/`ディレクトリを含みます。

スキルは`skills:`フロントマターフィールドを介してエージェントからプリロードでき、エージェントが実行中に呼び出せる再利用可能な機能（例：データ収集やフォーマット用のbashスクリプト）を提供します。

### 使用パターン

- **ディレクトリ名**: `plugins/<name>/skills/<skill-name>/`
- **ファイル名**: `SKILL.md`、`sh/generate.sh`、`sh/calculate.sh`
- **コード参照**: 「archive-ticketスキルは...を処理する」、「changelogスキルをプリロード」

### 現在のスキル

ユーティリティスキル（バンドルされたシェルスクリプト付き）:
- **archive-ticket**: 完了したチケットをブランチアーカイブに移動、コミットのフォーマット
- **create-branch**: タイムスタンプ付きトピックブランチを作成（例：`feat-20260128-001720`）
- **create-pr**: PR作成ワークフロー、タイトル導出、GitHub操作用シェルスクリプト
- **discover-history**: キーワードでアーカイブされたチケットを検索して関連する歴史的コンテキストを見つける
- **discover-source**: ソースコードを探索してコンテキストを理解するためのガイドライン
- **format-commit-message**: UXおよびArchセクション付きの構造化コミットメッセージ形式
- **handle-abandon**: 失敗分析を伴う放棄された実装を処理
- **request-approval**: 選択可能なオプション付きのユーザー承認フロー
- **write-final-report**: 最終レポートと発見されたインサイトのドキュメンテーション

コンテンツスキル（指示とテンプレート）:
- **write-story**: ストーリーコンテンツ構造、フォーマット、メトリクス計算、翻訳要件
- **write-spec**: スペックファイル形式、コンテンツガイドライン、更新のためのコンテキスト収集
- **write-terms**: 用語エントリ形式、ドキュメントガイドライン、更新のためのコンテキスト収集
- **write-changelog**: changelogフォーマットとエントリガイドライン
- **analyze-performance**: パフォーマンス評価フレームワーク
- **create-ticket**: チケットファイル構造、フロントマター、関連履歴、作成ワークフロー
- **drive-workflow**: チケット処理の実装ワークフロー調整
- **translate**: 翻訳ポリシーと`.workaholic/`のi18n適用

### 関連用語

- command、plugin、agent

## rule

プラグインコンテキスト内でClaudeの動作を形成するガイドラインと制約。

### 定義

ルールはプラグインのスコープ内で作業する際にClaudeが従う永続的なガイドラインを提供します。コーディング規約、ドキュメント要件、または動作制約を定義します。ルールはプラグインの`rules/`ディレクトリに保存されます。

### 使用パターン

- **ディレクトリ名**: `plugins/<name>/rules/`
- **ファイル名**: `general.md`、`typescript.md`
- **コード参照**: 「generalルールに従って...」

### 関連用語

- plugin、command

## agent

フォーカスされたタスクを独自のコンテキストウィンドウで処理するために生成される特殊なサブエージェント。

### 定義

エージェント（サブエージェントとも呼ばれる）は特定のプロンプトとツールを持つAIサブプロセスで実行されます。親の会話のコンテキストを保持しながら、大量のファイル読み取りや複雑な分析を独自のコンテキストウィンドウで実行します。コマンドはTaskツールを介してエージェントを呼び出し、構造化された出力を受け取ります。エージェントは他のエージェントを呼び出すこともできます（サブエージェントチェーン）。エージェントはプラグインの`agents/`ディレクトリで定義されます。

一般的なエージェントタイプ:
- **ライターエージェント**: ドキュメントを生成（spec-writer、terms-writer、story-writer、changelog-writer）
- **アナリストエージェント**: 評価と分析を実行（performance-analyst、release-readiness）
- **クリエイターエージェント**: 外部操作を実行（pr-creator）
- **検索エージェント**: 関連する作業を見つけて分析（history-discoverer、source-discoverer）

### 使用パターン

- **ディレクトリ名**: `plugins/<name>/agents/`
- **ファイル名**: `performance-analyst.md`、`release-readiness.md`、`spec-writer.md`、`story-writer.md`、`changelog-writer.md`、`pr-creator.md`、`terms-writer.md`、`history-discoverer.md`、`source-discoverer.md`
- **コード参照**: 「story-writerエージェントを呼び出す」、「changelog-writerエージェントが処理する...」、「Taskツールでエージェントを起動」

### 関連用語

- plugin、command、skill、orchestrator

## orchestrator

複雑なワークフローを完了するために複数のエージェントを調整するコマンド。

### 定義

オーケストレーターは、インラインでタスクを実行する代わりに、専門化された作業を複数のエージェントに委譲するコマンドです。オーケストレーターは初期コンテキストを収集し、エージェントを（パフォーマンスのために並列で）呼び出し、その出力を統合します。このパターンは、複雑なマルチステップワークフローを可能にしながら、メイン会話のコンテキストウィンドウを保持します。

例:
- `/story`はchangelog-writer、story-writer、spec-writer、terms-writer、release-readinessを同時に、その後pr-creatorを順次オーケストレート

### 使用パターン

- **ディレクトリ名**: N/A（パターンであり、ストレージではない）
- **ファイル名**: N/A
- **コード参照**: 「コマンドはオーケストレーターとして機能する」、「エージェントを並列でオーケストレート」

### 関連用語

- command、agent、concurrent execution

## deny

特定のコマンドパターンの実行をブロックするパーミッションルール。

### 定義

denyルールは`.claude/settings.json`の`permissions.deny`で設定され、サブエージェントを含むプロジェクト全体で特定のコマンドパターンを禁止します。個々のエージェント指示に禁止事項を埋め込む（サブエージェントは継承しない）のとは異なり、denyルールは実行前に一元的に適用されます。このパターンは、各エージェントファイルに指示を複製するよりも保守性が高くなります。

例：`"Bash(git -C:*)"`は、パーミッションプロンプトをトリガーするすべての`git -C`コマンドバリエーションをブロックします。

### 使用パターン

- **ディレクトリ名**: N/A（設定であり、ストレージではない）
- **ファイル名**: `.claude/settings.json`
- **コード参照**: 「...のdenyルールを追加」、「settings.json denyでコマンドをブロック」

### 関連用語

- rule、agent、settings

## preload

フロントマターを介してエージェントのコンテキストにスキルコンテンツをロード。

### 定義

preloadingは、エージェントが初期化時にスキルコンテンツにアクセスするためのメカニズムです。エージェントの`skills:`フロントマターフィールドでスキルを指定することにより、エージェントが生成されるときにスキルの`SKILL.md`コンテンツがエージェントのコンテキストに含まれます。これにより、エージェントは実行中に追加のファイルを読み取ることなく、再利用可能な指示、bashスクリプト、またはフォーマットルールにアクセスできます。

フロントマターの例:
```yaml
---
name: story-writer
skills: [story-metrics, i18n]
---
```

### 使用パターン

- **ディレクトリ名**: N/A（メカニズムであり、ストレージではない）
- **ファイル名**: N/A
- **コード参照**: 「フロントマターでスキルをプリロード」、「エージェントはchangelogスキルをプリロード」

### 関連用語

- skill、agent、frontmatter

## nesting-policy

コンポーネントタイプ間でどれがどれを呼び出せるかを規定するアーキテクチャルール。

### 定義

nesting policyは、コマンド、サブエージェント、スキル間で許可される呼び出しパターンと禁止される呼び出しパターンを定義します。このポリシーにより、オーケストレーション（コマンド、サブエージェント）とナレッジ（スキル）の間の明確な分離が確保されます。

**許可される呼び出し:**
- コマンド -> スキル（`skills:`フロントマターでプリロード）
- コマンド -> サブエージェント（Taskツール経由）
- サブエージェント -> スキル（`skills:`フロントマターでプリロード）
- スキル -> スキル（再利用可能なナレッジの構成のために`skills:`フロントマターでプリロード）

**禁止される呼び出し:**
- スキル -> サブエージェント（スキルは受動的なナレッジであり、オーケストレーターではない）
- スキル -> コマンド（スキルはユーザー向けコマンドを呼び出せない）
- サブエージェント -> サブエージェント（深いネスティングとコンテキスト爆発を防止）
- サブエージェント -> コマンド（サブエージェントはコマンドに呼び出される側であり、その逆ではない）

指導原則は「薄いコマンドとサブエージェント、包括的なスキル」:
- コマンド: オーケストレーションのみ（約50-100行）
- サブエージェント: オーケストレーションのみ（約20-40行）
- スキル: 包括的なナレッジ（約50-150行）

スキルは他のスキルをプリロードして再利用可能なナレッジを構成できます（例：write-spec はi18n適用のために translate をプリロード）。

### 使用パターン

- **ディレクトリ名**: N/A（ポリシーであり、ストレージではない）
- **ファイル名**: ルート`CLAUDE.md`のArchitecture Policyセクションにドキュメント化
- **コード参照**: 「nesting policyに従う」、「これはnesting policyに違反する」

### 関連用語

- command、agent、skill、orchestrator

## context-window

サブエージェントが実行するときの隔離された会話コンテキスト。

### 定義

context windowは、エージェントが実行するときに利用可能な会話メモリです。エージェントが隔離されたコンテキストで実行するとき、メイン会話のコンテキストウィンドウをオーケストレーション用に保持しながら、実装の詳細を独自の専用スペースで処理します。これは、大量のファイル読み取りや複雑な分析からのコンテキスト汚染を防ぎます。driverエージェントは、たとえば、メイン/driveコマンドの会話スペースを膨張させることなく、単一のチケットを実装するために独自のコンテキストウィンドウで実行されます。

### 使用パターン

- **ディレクトリ名**: N/A（コンセプトであり、ストレージではない）
- **ファイル名**: N/A
- **コード参照**: 「context windowを保持」、「隔離されたコンテキストで実行」、「Context window汚染」

### 関連用語

- agent、driver、orchestrator

## hook

Claude Code tool ライフサイクルの特定のポイントで実行されるコールバックメカニズム。

### 定義

フックはtool実行ワークフローの定義されたポイントでトリガーされ、ポリシーを強制するか自動アクションを実行します。Workaholicは現在、PostToolUseフックを使用してファイル操作を検証します（例：チケットファイルが保存される前にフォーマット要件を満たしていることを確認）。フックはプラグインの`hooks/hooks.json`ファイルで設定され、マッチング条件に基づいてシェルスクリプトまたは他のコマンドを実行できます。

Claude Codeは標準ロケーション（`plugins/<name>/hooks/hooks.json`）から`hooks/hooks.json`を明示的なマニフェストエントリなしで自動的にロードします。`plugin.json`の`hooks`フィールドは、標準外のhookファイル場所にのみ必要です。標準ロケーションのhookをマニフェストで宣言しないでください。これにより「Duplicate hooks file detected」エラーが発生します。

### 使用パターン

- **ディレクトリ名**: `plugins/<name>/hooks/`
- **ファイル名**: `hooks.json`（設定）、`*.sh`（実行可能スクリプト）
- **コード参照**: 「PostToolUseフックを追加」、「フックが保存前に検証」、「hooks.jsonのフック設定」

### フックタイプ

- **PostToolUse**: toolが呼び出された後に実行、検証または自動処理に有用

### オートロード動作

- 標準ロケーション`plugins/<name>/hooks/hooks.json`はClaude Codeにより自動的にロードされます
- 標準ロケーションのhookにはマニフェストエントリ（`plugin.json`の`hooks`フィールド）は不要です
- `hooks`フィールドは標準外のhookファイルパスにのみ必要です

### 関連用語

- rule、plugin、PostToolUse

## PostToolUse

Claude Codeツール実行後にトリガーされるフックのライフサイクルイベント。

### 定義

PostToolUseはフックトリガーポイントであり、プラグインがWriteやEditなどのtoolが正常に完了した直後に検証またはサイドエフェクトコードを実行することを可能にします。Workaholicでは、PostToolUseフックはチケットファイル操作を検証するために使用され、新しく作成または修正されたチケットファイルが完全に永続化される前にフォーマットと場所の要件を満たしていることを確認します。

### 使用パターン

- **ディレクトリ名**: N/A（フックタイプであり、ストレージではない）
- **ファイル名**: `hooks/hooks.json`マッチャー設定で参照
- **コード参照**: 「PostToolUseフックがファイルを検証」、「Write|EditのPostToolUse設定」

### 関連用語

- hook、rule、plugin

## TiDD

Ticket-Driven Development（チケット駆動開発）: チケットが計画と完了した作業の唯一の情報源として機能する方法論。

### 定義

TiDD（Ticket-Driven Development）はWorkaholicのコア哲学です。チケットを計画と成果の永続的で検索可能なレコードとしてラウンドするワークフローを再構成します。外部issue trackerではなく、チケットはコードと共にリポジトリ内で存在し、完全な開発履歴をアクセス可能にし、セマンティックコンテキストを保存します。各チケットは何を変更すべきか（Overview、Implementation Steps）、実際に何が起こったか（Final Report、Discovered Insights）、何を学んだか（Discovered Insights）を記録します。ワークフローは規律を強制します：計画（チケット作成）、実装（drive）、ドキュメント化（story）。これは決定の「理由」を保存し、バックログを一時的なタスクリストから歴史的資産に変換します。

### 使用パターン

- **ディレクトリ名**: N/A（哲学であり、ストレージではない）
- **ファイル名**: README.mdとプロジェクトドキュメントで参照
- **コード参照**: 「TiDD哲学」、「チケット駆動開発アプローチ」、「リポジトリ内のチケット」

### 関連用語

- ticket、drive、story、archive
